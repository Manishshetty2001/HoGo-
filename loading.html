<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Leaf Cell Immersion</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.11.4/dist/gsap.min.js"></script>
  <style>
    :root {
      --primary: #1a6b5e;
      --secondary: #4caf7d;
      --accent: #c5e86c;
      --cell-membrane: rgba(197, 232, 108, 0.15);
      --chloroplast: rgba(76, 175, 125, 0.3);
      --vacuole: rgba(255, 255, 255, 0.1);
    }
    
    body {
      margin: 0;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
      font-family: 'Inter', system-ui, sans-serif;
      position: relative;
      background: radial-gradient(circle at 50% 50%, 
        rgba(26, 107, 94, 0.95) 0%, 
        rgba(76, 175, 125, 0.85) 50%, 
        rgba(197, 232, 108, 0.75) 100%);
      animation: cellPulse 20s ease infinite alternate;
      background-size: 200% 200%;
      cursor: default;
      touch-action: manipulation;
    }

    @keyframes cellPulse {
      0% { background-position: 10% 10%; }
      50% { background-position: 100% 100%; }
      100% { background-position: 10% 100%; }
    }

    /* Cell wall pattern overlay - simplified */
    body::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image: 
        radial-gradient(var(--cell-membrane) 1px, transparent 1px);
      background-size: 150px 150px;
      opacity: 0.3;
      z-index: 0;
      animation: cellWallDrift 120s linear infinite;
    }

    @keyframes cellWallDrift {
      0% { background-position: 0 0; }
      100% { background-position: 150px 150px; }
    }

    #threejs-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      opacity: 0.8;
    }

    .loader-wrapper {
      width: 90%;
      max-width: 380px;
      display: flex;
      flex-direction: column;
      align-items: center;
      z-index: 10;
      perspective: 1000px;
      transform: translateY(-5%);
      padding: 20px;
      box-sizing: border-box;
    }

    .logo-orb {
      width: 180px;
      height: 180px;
      margin-bottom: 5px;
      position: relative;
      transform-style: preserve-3d;
      animation: float 8s ease-in-out infinite;
      filter: drop-shadow(0 10px 20px rgba(0,0,0,0.2));
    }

    @media (min-width: 768px) {
      .logo-orb {
        width: 220px;
        height: 220px;
      }
    }

    @keyframes float {
      0%, 100% { transform: translateY(0) rotateX(0) rotateY(0); }
      50% { transform: translateY(-10px) rotateX(3deg) rotateY(3deg); }
    }

    .logo-img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      filter: 
        drop-shadow(0 0 15px rgba(255, 255, 255, 0.6))
        brightness(1.1)
        saturate(1.2);
      opacity: 0;
      animation: 
        logoAppear 2s cubic-bezier(0.16, 1, 0.3, 1) forwards,
        subtleGlow 4s ease-in-out infinite alternate;
      animation-delay: 0.4s;
      transform-origin: center;
      transition: all 0.4s ease-out;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
    }

    @keyframes logoAppear {
      from { opacity: 0; transform: scale(0.8) rotateX(-15deg); }
      to { opacity: 1; transform: scale(1) rotateX(0); }
    }

    @keyframes subtleGlow {
      0% { filter: 
        drop-shadow(0 0 15px rgba(255, 255, 255, 0.6))
        brightness(1.1)
        saturate(1.2); 
        box-shadow: inset 0 0 30px rgba(197, 232, 108, 0.3); }
      100% { filter: 
        drop-shadow(0 0 25px rgba(197, 232, 108, 0.8))
        brightness(1.15)
        saturate(1.3); 
        box-shadow: inset 0 0 50px rgba(197, 232, 108, 0.5); }
    }

    .progress-3d {
      width: 100%;
      height: 8px;
      margin-top: 20px;
      position: relative;
      transform-style: preserve-3d;
      opacity: 0;
      animation: fadeIn 1s ease-out forwards;
      animation-delay: 0.8s;
    }

    .progress-track {
      position: absolute;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      transform: translateZ(-4px);
      box-shadow: 
        0 2px 10px rgba(0,0,0,0.1),
        inset 0 1px 2px rgba(255,255,255,0.1);
    }

    .progress-fill {
      position: absolute;
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, 
        rgba(255, 255, 255, 0.95) 0%, 
        rgba(197, 232, 108, 0.95) 100%);
      border-radius: 10px;
      transform: translateZ(0);
      transition: width 0.8s cubic-bezier(0.33, 1, 0.68, 1);
      box-shadow: 
        0 0 15px rgba(197, 232, 108, 0.5),
        inset 0 1px 2px rgba(255,255,255,0.3);
      overflow: hidden;
    }

    .progress-fill::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(90deg, 
        rgba(255,255,255,0) 0%, 
        rgba(255,255,255,0.6) 50%, 
        rgba(255,255,255,0) 100%);
      animation: shine 2.5s infinite;
      transform: translateX(-100%);
    }

    @keyframes shine {
      100% { transform: translateX(100%); }
    }

    .progress-text {
      margin-top: 10px;
      font-size: 14px;
      color: white;
      font-weight: 500;
      opacity: 0;
      transform: translateY(5px);
      animation: fadeInUp 1s ease-out forwards;
      animation-delay: 1s;
      text-shadow: 0 2px 4px rgba(0,0,0,0.2);
      font-feature-settings: "tnum";
      font-variant-numeric: tabular-nums;
      text-align: center;
      width: 100%;
    }

    @media (min-width: 768px) {
      .progress-text {
        font-size: 16px;
      }
    }

    @keyframes fadeInUp {
      from { opacity: 0; transform: translateY(5px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .quote-container {
      width: 100%;
      margin: 15px 0;
      position: relative;
    }

    .quote-card {
      width: 100%;
      min-height: 70px;
      padding: 15px;
      background: rgba(255, 255, 255, 0.12);
      backdrop-filter: blur(12px);
      border-radius: 14px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      box-shadow: 
        0 8px 32px rgba(0, 0, 0, 0.1),
        inset 0 1px 2px rgba(255, 255, 255, 0.1);
      color: white;
      text-align: center;
      opacity: 0;
      transform: translateY(10px) scale(0.98);
      transition: all 0.8s cubic-bezier(0.16, 1, 0.3, 1);
      position: relative;
      overflow: hidden;
    }

    .quote-card::before {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: radial-gradient(circle, 
        rgba(255,255,255,0.15) 0%, 
        transparent 70%);
      transform: rotate(30deg);
      animation: cardGlow 8s linear infinite;
    }

    @keyframes cardGlow {
      0% { transform: rotate(30deg) translateX(-100%); }
      100% { transform: rotate(30deg) translateX(100%); }
    }

    .quote-text {
      font-size: 14px;
      font-weight: 400;
      line-height: 1.5;
      text-shadow: 0 1px 3px rgba(0,0,0,0.3);
      opacity: 0.95;
      position: relative;
      margin: 0;
    }

    @media (min-width: 768px) {
      .quote-text {
        font-size: 15px;
      }
    }

    .quote-author {
      font-size: 12px;
      font-style: italic;
      margin-top: 8px;
      font-weight: 300;
      opacity: 0.8;
      position: relative;
    }

    @media (min-width: 768px) {
      .quote-author {
        font-size: 13px;
      }
    }

    .particles {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 2;
      pointer-events: none;
    }

    .particle {
      position: absolute;
      width: 3px;
      height: 3px;
      background: rgba(255, 255, 255, 0.6);
      border-radius: 50%;
      animation: particleFloat linear infinite;
      filter: blur(0.5px);
    }

    @keyframes particleFloat {
      to { transform: translateY(-100vh) rotate(360deg); }
    }

    .completion-effect {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at center, 
        rgba(255,255,255,0.8) 0%, 
        transparent 70%);
      opacity: 0;
      z-index: 5;
      pointer-events: none;
    }

    /* Enhanced Loading Line */
    .loading-line {
      position: fixed;
      top: 0;
      left: 0;
      height: 3px;
      width: 100%;
      background: linear-gradient(90deg, 
        transparent, 
        rgba(255,255,255,0.9), 
        transparent);
      z-index: 20;
      transform-origin: left center;
      transform: scaleX(0);
      transition: transform 0.3s ease-out;
    }

    .loading-line.active {
      animation: loadingLine 2s infinite cubic-bezier(0.4, 0, 0.2, 1);
    }

    @keyframes loadingLine {
      0% { transform: translateX(-100%) scaleX(0.5); }
      100% { transform: translateX(100%) scaleX(0.5); }
    }

    /* Simplified organelle styles */
    .chloroplast {
      position: absolute;
      width: 40px;
      height: 20px;
      border-radius: 50% / 100%;
      background: rgba(76, 175, 125, 0.15);
      filter: blur(1px);
      animation: chloroplastDrift linear infinite;
      z-index: 1;
      opacity: 0.3;
    }

    @keyframes chloroplastDrift {
      0% { transform: translate(0, 0) rotate(0deg); }
      100% { transform: translate(100px, 50px) rotate(360deg); }
    }

    /* Simplified mitochondria */
    .mitochondria {
      position: absolute;
      width: 30px;
      height: 15px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 50%;
      filter: blur(0.5px);
      animation: mitochondriaPulse 4s ease-in-out infinite alternate;
      z-index: 1;
      opacity: 0.2;
    }

    @keyframes mitochondriaPulse {
      0% { transform: scale(1); opacity: 0.2; }
      100% { transform: scale(1.1); opacity: 0.3; }
    }

    /* Simplified vacuole */
    .vacuole {
      position: absolute;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.05);
      animation: vacuolePulse 6s ease-in-out infinite alternate;
      z-index: 1;
      opacity: 0.1;
    }

    @keyframes vacuolePulse {
      0% { transform: scale(1); }
      100% { transform: scale(1.05); }
    }

    /* Simplified nucleus */
    .nucleus {
      position: absolute;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.1);
      animation: nucleusGlow 5s ease-in-out infinite alternate;
      z-index: 2;
      opacity: 0.1;
    }

    @keyframes nucleusGlow {
      0% { box-shadow: 0 0 5px rgba(255,255,255,0.05); }
      100% { box-shadow: 0 0 10px rgba(255,255,255,0.1); }
    }

    /* Mobile-specific adjustments */
    @media (max-width: 480px) {
      .logo-orb {
        width: 150px;
        height: 150px;
      }
      
      .quote-text {
        font-size: 13px;
      }
      
      .quote-author {
        font-size: 11px;
      }
      
      .progress-text {
        font-size: 13px;
      }
    }

    /* Prevent text selection for better mobile experience */
    * {
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
  </style>
</head>
<body>
  <!-- Three.js Container -->
  <div id="threejs-container"></div>
  
  <!-- Floating Particles -->
  <div class="particles" id="particles"></div>
  
  <!-- Cell Organelles - Reduced quantity -->
  <div id="organelles"></div>
  
  <!-- Completion Effect -->
  <div class="completion-effect" id="completionEffect"></div>
  
  <!-- Enhanced Loading Line -->
  <div class="loading-line active" id="loadingLine"></div>

  <div class="loader-wrapper">
    <div class="logo-orb">
      <img src="https://i.ibb.co/TxkzTR6y/1000281790.png" class="logo-img" alt="Leaf Cell Logo" id="logoImg">
    </div>

    <div class="quote-container">
      <div class="quote-card" id="quoteContainer">
        <p class="quote-text" id="quoteText">"In every walk with nature one receives far more than he seeks."</p>
        <div class="quote-author" id="quoteAuthor">- John Muir</div>
      </div>
    </div>

    <div class="progress-3d">
      <div class="progress-track"></div>
      <div class="progress-fill" id="progressBar"></div>
    </div>
    <div class="progress-text" id="progressText">0%</div>
  </div>

  <script>
    // Enhanced Three.js Scene Setup for Leaf Cell with smoother animations
    const threeContainer = document.getElementById('threejs-container');
    const scene = new THREE.Scene();
    scene.background = null;
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ 
      alpha: true, 
      antialias: true,
      powerPreference: "high-performance"
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    threeContainer.appendChild(renderer.domElement);

    // Create organic leaf vein structures with smoother curves
    const createVein = () => {
      const curve = new THREE.CubicBezierCurve3(
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(
          (Math.random() - 0.5) * 2,
          (Math.random() - 0.5) * 2,
          (Math.random() - 0.5) * 2
        ),
        new THREE.Vector3(
          (Math.random() - 0.5) * 4,
          (Math.random() - 0.5) * 4,
          (Math.random() - 0.5) * 4
        ),
        new THREE.Vector3(
          (Math.random() - 0.5) * 6,
          (Math.random() - 0.5) * 6,
          (Math.random() - 0.5) * 6
        )
      );
      
      const points = curve.getPoints(50 + Math.floor(Math.random() * 30));
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      
      const material = new THREE.LineBasicMaterial({
        color: new THREE.Color(`hsl(${100 + Math.random() * 40}, 70%, 60%)`),
        transparent: true,
        opacity: 0.2 + Math.random() * 0.2,
        linewidth: 1,
        linecap: 'round',
        linejoin: 'round'
      });
      
      const line = new THREE.Line(geometry, material);
      line.position.set(
        (Math.random() - 0.5) * 10,
        (Math.random() - 0.5) * 10,
        (Math.random() - 0.5) * 10
      );
      
      // Smoother animation properties
      line.userData = {
        speed: 0.005 + Math.random() * 0.01,
        rotationSpeed: (Math.random() - 0.5) * 0.005,
        offset: Math.random() * Math.PI * 2
      };
      
      scene.add(line);
      return line;
    };

    // Create detailed chloroplast models with smoother animations
    const createChloroplast = () => {
      const group = new THREE.Group();
      
      // Main chloroplast body (ellipsoid)
      const geometry = new THREE.SphereGeometry(0.3, 32, 32);
      geometry.scale(1.5, 1, 1);
      
      const material = new THREE.MeshPhongMaterial({
        color: new THREE.Color(`hsl(${100 + Math.random() * 20}, 70%, 50%)`),
        transparent: true,
        opacity: 0.15,
        specular: 0x111111,
        shininess: 30,
        flatShading: false
      });
      
      const chloroplast = new THREE.Mesh(geometry, material);
      group.add(chloroplast);
      
      // Thylakoid stacks (grana)
      for (let i = 0; i < 5 + Math.floor(Math.random() * 5); i++) {
        const thylakoid = new THREE.Mesh(
          new THREE.TorusGeometry(0.1 + Math.random() * 0.1, 0.02, 16, 24),
          new THREE.MeshBasicMaterial({
            color: new THREE.Color(`hsl(${80 + Math.random() * 40}, 80%, 60%)`),
            transparent: true,
            opacity: 0.3
          })
        );
        
        thylakoid.position.set(
          (Math.random() - 0.5) * 0.5,
          (Math.random() - 0.5) * 0.3,
          (Math.random() - 0.5) * 0.5
        );
        
        thylakoid.rotation.set(
          Math.random() * Math.PI,
          Math.random() * Math.PI,
          Math.random() * Math.PI
        );
        
        group.add(thylakoid);
      }
      
      group.position.set(
        (Math.random() - 0.5) * 10,
        (Math.random() - 0.5) * 10,
        (Math.random() - 0.5) * 10
      );
      
      // Smoother animation properties
      group.userData = {
        speed: 0.008 + Math.random() * 0.01,
        rotationSpeed: (Math.random() - 0.5) * 0.008,
        pulseSpeed: 0.5 + Math.random() * 0.5,
        offset: Math.random() * Math.PI * 2
      };
      
      scene.add(group);
      return group;
    };

    // Create mitochondria models with smoother animations
    const createMitochondria = () => {
      const group = new THREE.Group();
      
      // Outer membrane
      const outerGeometry = new THREE.SphereGeometry(0.2, 32, 32);
      outerGeometry.scale(1.5, 1, 1);
      
      const outerMaterial = new THREE.MeshPhongMaterial({
        color: new THREE.Color(`hsl(${40 + Math.random() * 20}, 50%, 60%)`),
        transparent: true,
        opacity: 0.1,
        wireframe: true,
        wireframeLinewidth: 1
      });
      
      const outer = new THREE.Mesh(outerGeometry, outerMaterial);
      group.add(outer);
      
      // Inner membrane (cristae)
      const innerGeometry = new THREE.SphereGeometry(0.15, 64, 64);
      innerGeometry.scale(1.3, 0.8, 1.3);
      
      // Displace vertices to create cristae folds
      const position = innerGeometry.attributes.position;
      for (let i = 0; i < position.count; i++) {
        const x = position.getX(i);
        const y = position.getY(i);
        const z = position.getZ(i);
        
        const displacement = 0.05 * Math.sin(x * 30) * Math.cos(z * 30);
        position.setXYZ(i, x * (1 + displacement), y, z * (1 + displacement));
      }
      
      position.needsUpdate = true;
      
      const innerMaterial = new THREE.MeshPhongMaterial({
        color: new THREE.Color(`hsl(${30 + Math.random() * 20}, 60%, 70%)`),
        transparent: true,
        opacity: 0.2,
        side: THREE.DoubleSide,
        flatShading: false
      });
      
      const inner = new THREE.Mesh(innerGeometry, innerMaterial);
      group.add(inner);
      
      group.position.set(
        (Math.random() - 0.5) * 10,
        (Math.random() - 0.5) * 10,
        (Math.random() - 0.5) * 10
      );
      
      // Smoother animation properties
      group.userData = {
        speed: 0.01 + Math.random() * 0.02,
        rotationSpeed: (Math.random() - 0.5) * 0.01,
        pulseSpeed: 0.3 + Math.random() * 0.4,
        offset: Math.random() * Math.PI * 2
      };
      
      scene.add(group);
      return group;
    };

    // Create nucleus model with smoother animations
    const createNucleus = () => {
      const group = new THREE.Group();
      
      // Main nucleus body
      const geometry = new THREE.SphereGeometry(0.5, 64, 64);
      
      const material = new THREE.MeshPhongMaterial({
        color: new THREE.Color(`hsl(${200 + Math.random() * 40}, 30%, 70%)`),
        transparent: true,
        opacity: 0.1,
        specular: 0x111111,
        shininess: 50,
        flatShading: false
      });
      
      const nucleus = new THREE.Mesh(geometry, material);
      group.add(nucleus);
      
      // Nuclear pores
      for (let i = 0; i < 20; i++) { // Reduced number of pores
        const pore = new THREE.Mesh(
          new THREE.TorusGeometry(0.05, 0.02, 16, 24),
          new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.3
          })
        );
        
        // Position on surface of sphere
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const radius = 0.5;
        
        pore.position.set(
          radius * Math.sin(phi) * Math.cos(theta),
          radius * Math.sin(phi) * Math.sin(theta),
          radius * Math.cos(phi)
        );
        
        // Orient to face outward
        pore.quaternion.setFromUnitVectors(
          new THREE.Vector3(0, 1, 0),
          pore.position.clone().normalize()
        );
        
        group.add(pore);
      }
      
      group.position.set(
        (Math.random() - 0.5) * 5,
        (Math.random() - 0.5) * 5,
        (Math.random() - 0.5) * 5
      );
      
      // Smoother animation properties
      group.userData = {
        speed: 0.003 + Math.random() * 0.005,
        rotationSpeed: (Math.random() - 0.5) * 0.003,
        pulseSpeed: 0.2 + Math.random() * 0.3,
        offset: Math.random() * Math.PI * 2
      };
      
      scene.add(group);
      return group;
    };

    // Create ribosomes with smoother animations
    const createRibosome = () => {
      const group = new THREE.Group();
      
      // Large subunit
      const largeSubunit = new THREE.Mesh(
        new THREE.SphereGeometry(0.08, 16, 16),
        new THREE.MeshPhongMaterial({
          color: new THREE.Color(`hsl(${10 + Math.random() * 20}, 70%, 60%)`),
          transparent: true,
          opacity: 0.3,
          flatShading: false
        })
      );
      
      // Small subunit
      const smallSubunit = new THREE.Mesh(
        new THREE.SphereGeometry(0.06, 16, 16),
        new THREE.MeshPhongMaterial({
          color: new THREE.Color(`hsl(${30 + Math.random() * 20}, 70%, 70%)`),
          transparent: true,
          opacity: 0.3,
          flatShading: false
        })
      );
      
      smallSubunit.position.set(0.1, 0, 0);
      
      group.add(largeSubunit);
      group.add(smallSubunit);
      
      group.position.set(
        (Math.random() - 0.5) * 10,
        (Math.random() - 0.5) * 10,
        (Math.random() - 0.5) * 10
      );
      
      // Smoother animation properties
      group.userData = {
        speed: 0.02 + Math.random() * 0.03,
        rotationSpeed: (Math.random() - 0.5) * 0.02,
        pulseSpeed: 0.4 + Math.random() * 0.5,
        offset: Math.random() * Math.PI * 2
      };
      
      scene.add(group);
      return group;
    };

    // Create vacuole with smoother animations
    const createVacuole = () => {
      const geometry = new THREE.SphereGeometry(0.8, 64, 64);
      
      // Create organic deformation
      const position = geometry.attributes.position;
      for (let i = 0; i < position.count; i++) {
        const x = position.getX(i);
        const y = position.getY(i);
        const z = position.getZ(i);
        
        const distortion = 0.1 * Math.sin(x * 15) * Math.sin(y * 15) * Math.sin(z * 15);
        position.setXYZ(i, x * (1 + distortion), y * (1 + distortion), z * (1 + distortion));
      }
      
      position.needsUpdate = true;
      
      const material = new THREE.MeshPhongMaterial({
        color: new THREE.Color(`hsl(${180 + Math.random() * 40}, 20%, 80%)`),
        transparent: true,
        opacity: 0.05,
        side: THREE.DoubleSide,
        flatShading: false
      });
      
      const vacuole = new THREE.Mesh(geometry, material);
      vacuole.position.set(
        (Math.random() - 0.5) * 8,
        (Math.random() - 0.5) * 8,
        (Math.random() - 0.5) * 8
      );
      
      // Smoother animation properties
      vacuole.userData = {
        speed: 0.005 + Math.random() * 0.01,
        rotationSpeed: (Math.random() - 0.5) * 0.005,
        pulseSpeed: 0.2 + Math.random() * 0.3,
        offset: Math.random() * Math.PI * 2
      };
      
      scene.add(vacuole);
      return vacuole;
    };

    // Create all cell components with reduced quantities
    const veins = [];
    const chloroplasts = [];
    const mitochondria = [];
    const ribosomes = [];
    const nuclei = [];
    const vacuoles = [];
    
    // Create cell wall/plasma membrane with smoother appearance
    const createCellMembrane = () => {
      const geometry = new THREE.SphereGeometry(12, 128, 128);
      
      // Create organic deformation for cell shape
      const position = geometry.attributes.position;
      for (let i = 0; i < position.count; i++) {
        const x = position.getX(i);
        const y = position.getY(i);
        const z = position.getZ(i);
        
        const distortion = 0.1 * Math.sin(x * 1.5) * Math.sin(y * 1.5) * Math.sin(z * 1.5);
        position.setXYZ(i, x * (1 + distortion), y * (1 + distortion), z * (1 + distortion));
      }
      
      position.needsUpdate = true;
      
      const material = new THREE.MeshPhongMaterial({
        color: new THREE.Color(`hsl(${100 + Math.random() * 20}, 30%, 60%)`),
        transparent: true,
        opacity: 0.02,
        side: THREE.DoubleSide,
        wireframe: true,
        wireframeLinewidth: 1
      });
      
      const membrane = new THREE.Mesh(geometry, material);
      scene.add(membrane);
      return membrane;
    };
    
    const cellMembrane = createCellMembrane();
    
    // Add cell components with reduced quantities
    for (let i = 0; i < 6; i++) { // Reduced veins
      veins.push(createVein());
    }
    
    for (let i = 0; i < 12; i++) { // Reduced chloroplasts
      chloroplasts.push(createChloroplast());
    }
    
    for (let i = 0; i < 8; i++) { // Reduced mitochondria
      mitochondria.push(createMitochondria());
    }
    
    for (let i = 0; i < 2; i++) { // Reduced nuclei
      nuclei.push(createNucleus());
    }
    
    for (let i = 0; i < 15; i++) { // Reduced ribosomes
      ribosomes.push(createRibosome());
    }
    
    for (let i = 0; i < 2; i++) { // Reduced vacuoles
      vacuoles.push(createVacuole());
    }

    // Add lighting with smoother transitions
    const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
    scene.add(ambientLight);
    
    const directionalLight1 = new THREE.DirectionalLight(0xc5e86c, 0.4);
    directionalLight1.position.set(1, 1, 1);
    scene.add(directionalLight1);
    
    const directionalLight2 = new THREE.DirectionalLight(0x4caf7d, 0.3);
    directionalLight2.position.set(-1, -1, -1);
    scene.add(directionalLight2);
    
    const pointLight = new THREE.PointLight(0xffffff, 0.6, 15);
    pointLight.position.set(0, 0, 5);
    scene.add(pointLight);
    
    // Add subtle fog for depth
    scene.fog = new THREE.FogExp2(0x1a6b5e, 0.02);

    // Camera position
    camera.position.z = 8;
    camera.lookAt(0, 0, 0);

    // Animation loop for Three.js with smoother animations
    const animate = () => {
      requestAnimationFrame(animate);
      
      const time = Date.now() * 0.001;
      
      // Animate veins with sine wave for smoother movement
      veins.forEach(vein => {
        vein.rotation.x += vein.userData.rotationSpeed;
        vein.rotation.y += vein.userData.rotationSpeed;
        
        // Sine wave movement for organic feel
        vein.position.y += Math.sin(time + vein.userData.offset) * 0.002;
        vein.position.x += Math.cos(time * 0.5 + vein.userData.offset) * 0.001;
        
        if (vein.position.y > 6) {
          vein.position.y = -6;
        }
      });
      
      // Animate chloroplasts with smoother pulsing
      chloroplasts.forEach(chloroplast => {
        chloroplast.rotation.x += chloroplast.userData.rotationSpeed;
        chloroplast.rotation.y += chloroplast.userData.rotationSpeed;
        
        // Sine wave movement
        chloroplast.position.y += Math.sin(time * 0.5 + chloroplast.userData.offset) * 0.003;
        chloroplast.position.x += Math.cos(time * 0.3 + chloroplast.userData.offset) * 0.002;
        
        // Smoother pulsing effect using sine wave
        const pulse = Math.sin(time * chloroplast.userData.pulseSpeed) * 0.03 + 1;
        chloroplast.scale.set(pulse, pulse, pulse);
        
        if (chloroplast.position.y > 6) {
          chloroplast.position.y = -6;
          chloroplast.position.x = (Math.random() - 0.5) * 10;
          chloroplast.position.z = (Math.random() - 0.5) * 10;
        }
      });
      
      // Animate mitochondria with smoother pulsing
      mitochondria.forEach(mito => {
        mito.rotation.x += mito.userData.rotationSpeed;
        mito.rotation.y += mito.userData.rotationSpeed;
        
        // Sine wave movement
        mito.position.y += Math.sin(time * 0.7 + mito.userData.offset) * 0.004;
        mito.position.x += Math.cos(time * 0.4 + mito.userData.offset) * 0.003;
        
        // Smoother pulsing effect (ATP production!)
        const pulse = Math.sin(time * mito.userData.pulseSpeed) * 0.05 + 1;
        mito.scale.set(pulse, pulse, pulse);
        
        if (mito.position.y > 6) {
          mito.position.y = -6;
        }
      });
      
      // Animate ribosomes with smoother random movement
      ribosomes.forEach(ribosome => {
        ribosome.rotation.x += ribosome.userData.rotationSpeed;
        ribosome.rotation.y += ribosome.userData.rotationSpeed;
        
        // Smoother random movement using perlin/sine noise
        ribosome.position.x += Math.sin(time * 0.2 + ribosome.userData.offset) * 0.01;
        ribosome.position.y += Math.cos(time * 0.25 + ribosome.userData.offset) * 0.01;
        ribosome.position.z += Math.sin(time * 0.3 + ribosome.userData.offset) * 0.01;
        
        // Translation movement
        if (ribosome.position.length() > 8) {
          ribosome.position.set(
            (Math.random() - 0.5) * 6,
            (Math.random() - 0.5) * 6,
            (Math.random() - 0.5) * 6
          );
        }
      });
      
      // Animate nuclei with smoother movement
      nuclei.forEach(nucleus => {
        nucleus.rotation.x += nucleus.userData.rotationSpeed;
        nucleus.rotation.y += nucleus.userData.rotationSpeed;
        
        // Sine wave movement
        nucleus.position.y += Math.sin(time * 0.3 + nucleus.userData.offset) * 0.002;
        
        if (nucleus.position.y > 4) {
          nucleus.position.y = -4;
        }
      });
      
      // Animate vacuoles with smoother pulsing
      vacuoles.forEach(vacuole => {
        vacuole.rotation.x += vacuole.userData.rotationSpeed * 0.5;
        vacuole.rotation.y += vacuole.userData.rotationSpeed * 0.5;
        
        // Slow, smooth pulsing
        const pulse = Math.sin(time * vacuole.userData.pulseSpeed) * 0.01 + 1;
        vacuole.scale.set(pulse, pulse, pulse);
      });
      
      // Animate cell membrane with smoother rotation
      cellMembrane.rotation.x += 0.0005;
      cellMembrane.rotation.y += 0.0005;
      
      renderer.render(scene, camera);
    };
    animate();

    // Handle window resize
    const handleResize = () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      
      // Adjust loader wrapper position for mobile
      if (window.innerHeight < 600) {
        document.querySelector('.loader-wrapper').style.transform = 'translateY(-15%)';
      } else {
        document.querySelector('.loader-wrapper').style.transform = 'translateY(-5%)';
      }
    };

    window.addEventListener('resize', handleResize);
    handleResize(); // Initial call

    // Create floating particles (like cytoplasm streaming) with smoother movement
    const particlesContainer = document.getElementById('particles');
    for (let i = 0; i < 80; i++) { // Reduced particles for mobile
      const particle = document.createElement('div');
      particle.classList.add('particle');
      particle.style.left = `${Math.random() * 100}%`;
      particle.style.top = `${Math.random() * 100}%`;
      particle.style.opacity = 0.1 + Math.random() * 0.3;
      particle.style.width = `${1 + Math.random() * 2}px`;
      particle.style.height = particle.style.width;
      particle.style.animationDuration = `${30 + Math.random() * 60}s`;
      particle.style.animationDelay = `${Math.random() * 10}s`;
      particle.style.backgroundColor = `hsl(${80 + Math.random() * 40}, 60%, 70%)`;
      particle.style.animationTimingFunction = 'cubic-bezier(0.4, 0, 0.2, 1)';
      particlesContainer.appendChild(particle);
    }

    // Create organelle divs with reduced quantity and lower opacity
    const organellesContainer = document.getElementById('organelles');
    for (let i = 0; i < 6; i++) { // Reduced organelles for mobile
      // Chloroplasts
      const chloroplast = document.createElement('div');
      chloroplast.classList.add('chloroplast');
      chloroplast.style.left = `${Math.random() * 100}%`;
      chloroplast.style.top = `${Math.random() * 100}%`;
      chloroplast.style.width = `${30 + Math.random() * 20}px`;
      chloroplast.style.height = `${15 + Math.random() * 10}px`;
      chloroplast.style.animationDuration = `${60 + Math.random() * 120}s`;
      chloroplast.style.animationDelay = `${Math.random() * 15}s`;
      chloroplast.style.animationTimingFunction = 'cubic-bezier(0.4, 0, 0.2, 1)';
      organellesContainer.appendChild(chloroplast);
      
      // Mitochondria
      const mitochondria = document.createElement('div');
      mitochondria.classList.add('mitochondria');
      mitochondria.style.left = `${Math.random() * 100}%`;
      mitochondria.style.top = `${Math.random() * 100}%`;
      mitochondria.style.width = `${20 + Math.random() * 10}px`;
      mitochondria.style.height = `${10 + Math.random() * 5}px`;
      mitochondria.style.animationDuration = `${5 + Math.random() * 3}s`;
      organellesContainer.appendChild(mitochondria);
      
      // Vacuoles
      const vacuole = document.createElement('div');
      vacuole.classList.add('vacuole');
      vacuole.style.left = `${Math.random() * 100}%`;
      vacuole.style.top = `${Math.random() * 100}%`;
      vacuole.style.width = `${50 + Math.random() * 50}px`;
      vacuole.style.height = vacuole.style.width;
      vacuole.style.animationDuration = `${8 + Math.random() * 4}s`;
      organellesContainer.appendChild(vacuole);
    }
    
    // Add nucleus with reduced glow
    const nucleus = document.createElement('div');
    nucleus.classList.add('nucleus');
    nucleus.style.left = '50%';
    nucleus.style.top = '50%';
    nucleus.style.width = '120px';
    nucleus.style.height = '120px';
    nucleus.style.transform = 'translate(-50%, -50%)';
    nucleus.style.animationDuration = '6s';
    organellesContainer.appendChild(nucleus);

    // DOM Elements
    const progressText = document.getElementById('progressText');
    const progressBar = document.getElementById('progressBar');
    const quoteContainer = document.getElementById('quoteContainer');
    const quoteText = document.getElementById('quoteText');
    const quoteAuthor = document.getElementById('quoteAuthor');
    const completionEffect = document.getElementById('completionEffect');
    const loadingLine = document.getElementById('loadingLine');
    const logoImg = document.getElementById('logoImg');

    // Nature quotes
    const natureQuotes = [
      {
        text: "The global food supply chain must become more resilient, more transparent, and more inclusive to sustainably feed the world..",
        author: "Jim Borel "
      },
      {
        text: "Sustainability and traceability are no longer optional in the ag supply chain they are demanded by customers and consumers alike.",
        author: "David MacLennan"
      },
      {
        text: "In every walk with nature one receives far more than he seeks.",
        author: "John Muir"
      },
      {
        text: "We cannot close our eyes to where and how our food is grown. A fair, inclusive agricultural value chain is essential for global stability.",
        author: "Paul Polman"
      },
      {
        text: "Supply chains determine the footprint of agriculture. If we fix the chain, we fix food.",
        author: "Dr. Jason Clay "
      },
      {
        text: "To sit in the shade on a fine day and look upon verdure is the most perfect refreshment.",
        author: "Jane Austen"
      },
      {
        text: "Nature does not hurry, yet everything is accomplished.",
        author: "Lao Tzu"
      },
      {
        text: "The clearest way into the Universe is through a forest wilderness.",
        author: "John Muir"
      },
      {
        text: "Plants are the young of the world, vessels of health and vigor.",
        author: "Ralph Waldo Emerson"
      },
      {
        text: "A leaf of grass is no less than the journey-work of the stars.",
        author: "Walt Whitman"
      }
    ];

    // Loading stages with cell biology theme
    const stages = [
      { progress: 0, label: "Initializing Cell Membrane..." },
      { progress: 8, label: "Synthesizing Cytoplasm..." },
      { progress: 18, label: "Assembling Nucleus..." },
      { progress: 28, label: "Generating Chloroplasts..." },
      { progress: 40, label: "Forming Mitochondria..." },
      { progress: 52, label: "Developing Vacuoles..." },
      { progress: 65, label: "Creating Ribosomes..." },
      { progress: 75, label: "Building Cell Wall..." },
      { progress: 85, label: "Activating Photosynthesis..." },
      { progress: 92, label: "Final Cellular Adjustments..." },
      { progress: 100, label: "Cell Fully Functional!" }
    ];

    let currentStage = 0;
    let isComplete = false;

    // Show random quote with smoother transition
    const showQuote = () => {
      if (isComplete) return;
      
      gsap.to(quoteContainer, {
        opacity: 0,
        y: 10,
        scale: 0.95,
        duration: 0.6,
        ease: "power2.inOut",
        onComplete: () => {
          const randomQuote = natureQuotes[Math.floor(Math.random() * natureQuotes.length)];
          quoteText.textContent = `"${randomQuote.text}"`;
          quoteAuthor.textContent = `- ${randomQuote.author}`;
          
          gsap.to(quoteContainer, {
            opacity: 1,
            y: 0,
            scale: 1,
            duration: 1,
            ease: "elastic.out(1, 0.3)"
          });
        }
      });
    };

    // Update progress through stages with smoother transitions
    const updateProgress = () => {
      if (currentStage < stages.length) {
        const stage = stages[currentStage];
        
        // Update progress bar with organic feel
        gsap.to(progressBar, {
          width: `${stage.progress}%`,
          duration: 1.2,
          ease: "sine.inOut",
          onUpdate: () => {
            const currentWidth = parseFloat(progressBar.style.width) || 0;
            progressText.textContent = `${Math.floor(currentWidth)}%`;
            
            // Smoother pulsing effect when reaching certain milestones
            if (Math.floor(currentWidth) % 25 === 0) {
              gsap.to(progressBar, {
                scaleY: 1.4,
                duration: 0.5,
                yoyo: true,
                repeat: 1,
                ease: "elastic.out(1, 0.5)"
              });
            }
          }
        });
        
        // Update status text with smoother typing effect
        const chars = stage.label.split('');
        progressText.textContent = '';
        
        chars.forEach((char, i) => {
          setTimeout(() => {
            progressText.textContent += char;
            // Add slight bounce to each character
            gsap.to(progressText, {
              y: -2,
              duration: 0.1,
              yoyo: true,
              repeat: 1,
              ease: "power1.out"
            });
          }, i * 20);
        });
        
        currentStage++;
        
        // Dynamic timing based on progress stage with smoother progression
        let delay;
        if (stage.progress < 30) {
          delay = 800 + Math.random() * 400;
        } else if (stage.progress < 70) {
          delay = 500 + Math.random() * 300;
        } else {
          delay = 200 + Math.random() * 100;
        }
        
        setTimeout(updateProgress, delay);
      } else {
        isComplete = true;
        completeAnimation();
      }
    };

    // Completion animation with smoother effects
    const completeAnimation = () => {
      // Progress bar celebration
      gsap.to(progressBar, {
        boxShadow: '0 0 30px rgba(197, 232, 108, 0.9)',
        duration: 1.5,
        repeat: 3,
        yoyo: true,
        ease: "sine.inOut"
      });
      
      // Completion glow effect
      gsap.to(completionEffect, {
        opacity: 0.8,
        duration: 2,
        ease: "power2.out",
        onComplete: () => {
          gsap.to(completionEffect, {
            opacity: 0,
            duration: 1.5,
            ease: "power2.in"
          });
        }
      });
      
      // Animate loading line to fade out smoothly
      gsap.to(loadingLine, {
        opacity: 0,
        duration: 1,
        ease: "power2.out",
        onComplete: () => {
          loadingLine.style.display = 'none';
        }
      });
      
      // Final quote display with smoother transition
      setTimeout(() => {
        gsap.to(quoteContainer, {
          backgroundColor: 'rgba(197, 232, 108, 0.25)',
          duration: 1.5,
          ease: "power2.inOut",
          onComplete: () => {
            quoteText.textContent = '"The cell is the fundamental unit of life."';
            quoteAuthor.textContent = '- Matthias Schleiden';
            gsap.to(quoteContainer, {
              scale: 1.05,
              duration: 0.5,
              yoyo: true,
              repeat: 1
            });
          }
        });
      }, 1500);
    };

    // Initialize animations with smoother sequence
    setTimeout(() => {
      // Show initial quote with delay
      setTimeout(showQuote, 500);
      
      // Start progress with delay
      setTimeout(updateProgress, 1000);
      
      // Change quote every 6-8 seconds with smoother timing
      setInterval(showQuote, 7000 + Math.random() * 2000);
    }, 1500);

    // Logo interaction effects with smoother animations
    logoImg.addEventListener('mouseenter', () => {
      gsap.to(logoImg, {
        scale: 1.05,
        filter: 'drop-shadow(0 0 30px rgba(197, 232, 108, 0.9)) brightness(1.2) saturate(1.4)',
        duration: 0.5,
        ease: "elastic.out(1, 0.5)"
      });
    });

    logoImg.addEventListener('mouseleave', () => {
      gsap.to(logoImg, {
        scale: 1,
        filter: 'drop-shadow(0 0 15px rgba(255, 255, 255, 0.6)) brightness(1.1) saturate(1.2)',
        duration: 0.5,
        ease: "elastic.out(1, 0.5)"
      });
    });

    logoImg.addEventListener('click', () => {
      gsap.to(logoImg, {
        scale: 0.95,
        duration: 0.2,
        yoyo: true,
        repeat: 1,
        ease: "power2.inOut"
      });
      
      // Create smoother cellular ripple effect
      const ripple = document.createElement('div');
      ripple.style.position = 'absolute';
      ripple.style.width = '100%';
      ripple.style.height = '100%';
      ripple.style.borderRadius = '50%';
      ripple.style.background = 'radial-gradient(circle, rgba(255,255,255,0.8) 0%, transparent 70%)';
      ripple.style.transform = 'scale(0)';
      ripple.style.opacity = '1';
      ripple.style.pointerEvents = 'none';
      document.querySelector('.logo-orb').appendChild(ripple);
      
      gsap.to(ripple, {
        scale: 2,
        opacity: 0,
        duration: 1.5,
        ease: "power2.out",
        onComplete: () => ripple.remove()
      });
    });

    // Background animation on mouse move (smoother parallax)
    const handleMouseMove = (e) => {
      const x = e.clientX / window.innerWidth;
      const y = e.clientY / window.innerHeight;
      
      // Move camera smoothly for parallax
      gsap.to(camera.position, {
        x: (x - 0.5) * 1.5,
        y: -(y - 0.5) * 1.5,
        duration: 4,
        ease: "power2.out"
      });
      
      // Move point light smoothly with mouse
      gsap.to(pointLight.position, {
        x: (x - 0.5) * 3,
        y: -(y - 0.5) * 3,
        duration: 2,
        ease: "power2.out"
      });
      
      // Logo parallax effect with smoother movement
      const logoX = (x - 0.5) * 3;
      const logoY = (y - 0.5) * 3;
      gsap.to('.logo-orb', {
        x: logoX,
        y: logoY,
        rotateX: logoY * 0.2,
        rotateY: logoX * 0.2,
        duration: 1.5,
        ease: "power2.out"
      });
      
      // Quote card subtle movement with smoother effect
      gsap.to(quoteContainer, {
        y: logoY * 0.3,
        duration: 1.5,
        ease: "power2.out"
      });
    };

    // Touch event handler for mobile devices
    const handleTouchMove = (e) => {
      const touch = e.touches[0] || e.changedTouches[0];
      const x = touch.clientX / window.innerWidth;
      const y = touch.clientY / window.innerHeight;
      
      // Move camera smoothly for parallax
      gsap.to(camera.position, {
        x: (x - 0.5) * 1.5,
        y: -(y - 0.5) * 1.5,
        duration: 4,
        ease: "power2.out"
      });
      
      // Move point light smoothly with touch
      gsap.to(pointLight.position, {
        x: (x - 0.5) * 3,
        y: -(y - 0.5) * 3,
        duration: 2,
        ease: "power2.out"
      });
      
      // Logo parallax effect with smoother movement
      const logoX = (x - 0.5) * 3;
      const logoY = (y - 0.5) * 3;
      gsap.to('.logo-orb', {
        x: logoX,
        y: logoY,
        rotateX: logoY * 0.2,
        rotateY: logoX * 0.2,
        duration: 1.5,
        ease: "power2.out"
      });
      
      // Quote card subtle movement with smoother effect
      gsap.to(quoteContainer, {
        y: logoY * 0.3,
        duration: 1.5,
        ease: "power2.out"
      });
    };

    // Add event listeners for both mouse and touch
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('touchmove', handleTouchMove);
  </script>
</body>
</html>